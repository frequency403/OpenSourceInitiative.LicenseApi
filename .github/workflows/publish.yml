name: Publish NuGet

on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  actions: read

jobs:
  pack-and-publish:
    name: Pack & Publish (release -> main)
    if: |
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'main' &&
      startsWith(github.event.pull_request.head.ref, 'release/v')
    runs-on: ubuntu-latest

    steps:
      - name: Resolve tag + ensure CI succeeded for release SHA
        id: gate
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const releaseBranch = context.payload.pull_request.head.ref; // e.g. release/v1.2.3
            const releaseSha = context.payload.pull_request.head.sha;

            const m = /^release\/(v\d+\.\d+\.\d+)$/.exec(releaseBranch);
            if (!m) {
              core.setFailed(`Release branch '${releaseBranch}' does not match 'release/vX.Y.Z'`);
              return;
            }

            const tag = m[1]; // vX.Y.Z

            // 1) Verify that the tag exists and points EXACTLY to the release SHA
            const refName = `tags/${tag}`;
            let ref;
            try {
              ref = await github.rest.git.getRef({ owner, repo, ref: refName });
            } catch (e) {
              core.setFailed(`Expected tag '${tag}' was not found. Create tag '${tag}' on the release branch tip before merging.`);
              return;
            }

            const tagSha = ref.data.object.sha;
            if (tagSha !== releaseSha) {
              core.setFailed(
                `Tag '${tag}' points to ${tagSha}, but PR head is ${releaseSha}. ` +
                `Tag must be created on the latest commit of '${releaseBranch}' before merge.`
              );
              return;
            }

            // 2) Verify CI workflow succeeded for that SHA (real dependency)
            // NOTE: "CI" must match your workflow name.
            const { data: runs } = await github.rest.actions.listWorkflowRunsForWorkflow({
              owner,
              repo,
              workflow_id: "CI",
              head_sha: releaseSha,
              per_page: 20
            });

            const successful = runs.workflow_runs.find(r => r.conclusion === "success");
            if (!successful) {
              core.setFailed(`No successful CI run found for ${releaseSha}. Make sure CI ran and passed for the tagged release commit.`);
              return;
            }

            core.info(`Gate OK: tag '${tag}' exists on release SHA and CI succeeded (run id ${successful.id}).`);
            core.setOutput("tag", tag);
            core.setOutput("version", tag.replace(/^v/, ""));

      - name: Checkout tag
        uses: actions/checkout@v6
        with:
          ref: ${{ steps.gate.outputs.tag }}
          fetch-depth: 0

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: '10.0.x'

      - name: Restore
        run: dotnet restore

      - name: Build
        run: dotnet build -c Release --no-restore

      - name: Pack Core package
        run: >-
          dotnet pack OpenSourceInitiative.LicenseApi/OpenSourceInitiative.LicenseApi.csproj
          -c Release -o ./nupkg
          --no-build
          -p:PackageVersion=${{ steps.gate.outputs.version }}
          -p:ContinuousIntegrationBuild=true

      - name: Publish to NuGet.org
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: >-
          dotnet nuget push "./nupkg/*.nupkg"
          --api-key "$NUGET_API_KEY"
          --source https://api.nuget.org/v3/index.json
          --skip-duplicate

      - name: Create GitHub Release and upload packages
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.gate.outputs.tag }}
          name: ${{ steps.gate.outputs.tag }}
          prerelease: false
          generate_release_notes: true
          files: |
            nupkg/*.nupkg